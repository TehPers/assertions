use std::fmt::{Debug, Display, Formatter};

use crate::specialization::__SpecializeWrapper;

#[macro_export]
#[doc(hidden)]
macro_rules! annotated {
    ($value:expr) => {{
        #[allow(unused_imports)]
        use $crate::specialization::annotated::*;

        // $value needs to be used as a value before it's stringified to get
        // proper completions from tools like rust-analyzer
        let mut annotated = $crate::metadata::Annotated::__new($value, ::std::stringify!($value));
        let wrapper = annotated.__specialize();
        wrapper
            .__for_trait::<dyn ::std::fmt::Debug>()
            .__kind()
            .__apply(&mut annotated);
        wrapper
            .__for_trait::<dyn ::std::fmt::Display>()
            .__kind()
            .__apply(&mut annotated);

        annotated
    }};
}

/// A value annotated with its string representation.
///
/// This holds a string representation of the stored value. The string
/// representation is obtained in the following order of precedence:
///
/// 1. the [`Debug`] representation, otherwise...
/// 2. the [stringified](std::stringify) source code (that was annotated).
///
/// The stringified source code is always available as well, which can be
/// helpful for providing error messages that refer to the actual source code
/// of a value.
///
/// One drawback is that if the annotated value was a variable, the source
/// representation is the name of that variable, which may provide limited
/// information about the actual value that was annotated. This can happen, for
/// example, if a value is an annotated input into an assertion and was
/// generated by the [`expect!`](crate::expect!) macro (which annotates
/// intermediate values inside of closures). In this case, the only way to
/// generate a meaningful string representation of the value is for that value
/// to implement [`Debug`].
///
/// This type makes no guarantees about the string representation of the
/// contained value except for where the representation comes from. Two
/// different compiler versions may result in two different string
/// representations (due to [stringify]'s lack of guarantee). The string
/// representation is *only* intended to be used to augment user-facing
/// messages.
#[derive(Clone, Debug)]
pub struct Annotated<T> {
    value: T,
    stringified: &'static str,
    as_debug: Option<fn(&T) -> &dyn Debug>,
    as_display: Option<fn(&T) -> &dyn Display>,
}

impl<T> Annotated<T> {
    #[inline]
    #[doc(hidden)]
    pub fn __new(value: T, stringified: &'static str) -> Self {
        Self {
            stringified,
            value,
            as_debug: None,
            as_display: None,
        }
    }

    #[inline]
    #[doc(hidden)]
    pub fn __specialize(&self) -> __SpecializeWrapper<T> {
        __SpecializeWrapper::new()
    }

    /// Gets a reference to the inner value.
    #[inline]
    pub fn inner(&self) -> &T {
        &self.value
    }

    /// Gets a mutable reference to the inner value.
    #[inline]
    pub fn inner_mut(&mut self) -> &mut T {
        &mut self.value
    }

    /// Extracts the inner value.
    #[inline]
    pub fn into_inner(self) -> T {
        self.value
    }

    /// Gets the stringified input's source code.
    #[inline]
    pub fn as_stringified(&self) -> &'static str {
        self.stringified
    }

    /// Gets a reference to the inner value as a `dyn Debug`.
    #[inline]
    pub fn as_debug(&self) -> Option<&dyn Debug> {
        self.as_debug.map(|f| f(&self.value))
    }

    /// Gets a reference to the inner value as a `dyn Display`.
    #[inline]
    pub fn as_display(&self) -> Option<&dyn Display> {
        self.as_display.map(|f| f(&self.value))
    }

    /// Gets whether this value has a representation other than the stringified
    /// source code representation.
    ///
    /// The stringified source code is not always useful (since it can be an
    /// intermediate variable name, for example), so sometimes it's helpful to
    /// know if a known useful representation of this value exists.
    #[inline]
    pub fn has_non_stringified_repr(&self) -> bool {
        self.as_debug.is_some() || self.as_display.is_some()
    }
}

impl<T> Annotated<T>
where
    T: Debug,
{
    #[inline]
    pub(crate) fn mark_debug(&mut self) {
        self.as_debug = Some(|val| val)
    }
}

impl<T> Annotated<T>
where
    T: Display,
{
    #[inline]
    pub(crate) fn mark_display(&mut self) {
        self.as_display = Some(|val| val)
    }
}

impl<T> Display for Annotated<T> {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        // We skip the display representation since we don't want to show it
        // most of the time. Usually the debug representation is more concise
        // and useful in debug output.
        if let Some(debug) = self.as_debug() {
            debug.fmt(f)
        } else {
            Display::fmt(self.as_stringified(), f)
        }
    }
}

#[cfg(test)]
mod tests {
    use test_case::test_case;

    use crate::metadata::Annotated;

    struct UseStringify<T>(T);

    #[derive(Debug)]
    struct UseDebug<T>(T);

    #[test_case(annotated!(1) => true; "simple")]
    #[test_case(annotated!(1 + 3) => true; "addition")]
    #[test_case(annotated!("hi") => true; "string")]
    #[test_case(annotated!(UseDebug(1)) => true; "debug only")]
    #[test_case(annotated!(UseStringify(1)) => false; "stringify only")]
    fn has_debug<T>(annotated: Annotated<T>) -> bool {
        annotated.as_debug().is_some()
    }

    #[test_case(annotated!(1) => true; "simple")]
    #[test_case(annotated!(1 + 3) => true; "addition")]
    #[test_case(annotated!("hi") => true; "string")]
    #[test_case(annotated!(UseDebug(1)) => false; "debug only")]
    #[test_case(annotated!(UseStringify(1)) => false; "stringify only")]
    fn has_display<T>(annotated: Annotated<T>) -> bool {
        annotated.as_display().is_some()
    }
}
